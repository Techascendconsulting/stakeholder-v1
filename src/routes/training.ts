import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';

interface StartSessionRequest {
  stageId: string;
  projectId: string;
  mode: 'practice' | 'assess';
  selectedStakeholders: string[];
}

interface SendMessageRequest {
  sessionId: string;
  message: string;
  stakeholderId?: string;
}

interface HintEventRequest {
  sessionId: string;
  stageId: string;
  cardId?: string;
  eventType: 'shown' | 'clicked' | 'edited' | 'asked';
  payload?: any;
}

export default async function trainingRoutes(fastify: FastifyInstance) {
  // Start a new training session
  fastify.post('/api/training/sessions/start', async (request: FastifyRequest<{ Body: StartSessionRequest }>, reply: FastifyReply) => {
    try {
      const { stageId, projectId, mode, selectedStakeholders } = request.body;

      // Create new session
      const sessionResult = await fastify.db.query(
        `INSERT INTO user_meetings (
          stage_id, 
          project_id, 
          mode, 
          selected_stakeholders, 
          status, 
          transcript,
          created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, NOW()) 
        RETURNING *`,
        [
          stageId,
          projectId,
          mode,
          selectedStakeholders,
          'active',
          []
        ]
      );

      const session = sessionResult.rows[0];

      return {
        success: true,
        data: {
          sessionId: session.id,
          stageId: session.stage_id,
          projectId: session.project_id,
          mode: session.mode,
          selectedStakeholders: session.selected_stakeholders,
          status: session.status,
          createdAt: session.created_at
        }
      };

    } catch (error) {
      console.error('Start session error:', error);
      return reply.status(500).send({
        success: false,
        error: 'Internal server error'
      });
    }
  });

  // Get session details
  fastify.get('/api/training/sessions/:sessionId', async (request: FastifyRequest<{ Params: { sessionId: string } }>, reply: FastifyReply) => {
    try {
      const { sessionId } = request.params;

      const result = await fastify.db.query(
        'SELECT * FROM user_meetings WHERE id = $1',
        [sessionId]
      );

      if (!result.rows[0]) {
        return reply.status(404).send({
          success: false,
          error: 'Session not found'
        });
      }

      const session = result.rows[0];

      return {
        success: true,
        data: {
          sessionId: session.id,
          stageId: session.stage_id,
          projectId: session.project_id,
          mode: session.mode,
          selectedStakeholders: session.selected_stakeholders,
          status: session.status,
          transcript: session.transcript,
          createdAt: session.created_at
        }
      };

    } catch (error) {
      console.error('Get session error:', error);
      return reply.status(500).send({
        success: false,
        error: 'Internal server error'
      });
    }
  });

  // Send message in training session
  fastify.post('/api/training/sessions/:sessionId/message', async (request: FastifyRequest<{ Body: SendMessageRequest; Params: { sessionId: string } }>, reply: FastifyReply) => {
    try {
      const { sessionId } = request.params;
      const { message, stakeholderId } = request.body;

      // Get current session
      const sessionResult = await fastify.db.query(
        'SELECT * FROM user_meetings WHERE id = $1',
        [sessionId]
      );

      if (!sessionResult.rows[0]) {
        return reply.status(404).send({
          success: false,
          error: 'Session not found'
        });
      }

      const session = sessionResult.rows[0];
      const transcript = session.transcript || [];

      // Add learner message
      transcript.push({
        role: 'learner',
        text: message,
        ts: new Date().toISOString()
      });

      // Generate AI response (this would integrate with your AI service)
      // For now, we'll add a placeholder response
      const aiResponse = {
        role: 'stakeholder',
        text: `Thank you for your question about ${session.stage_id}. This is a placeholder response that would be generated by the AI system.`,
        ts: new Date().toISOString(),
        stakeholderId: stakeholderId
      };

      transcript.push(aiResponse);

      // Update session with new transcript
      await fastify.db.query(
        'UPDATE user_meetings SET transcript = $1, updated_at = NOW() WHERE id = $2',
        [transcript, sessionId]
      );

      return {
        success: true,
        data: {
          message: aiResponse
        }
      };

    } catch (error) {
      console.error('Send message error:', error);
      return reply.status(500).send({
        success: false,
        error: 'Internal server error'
      });
    }
  });

  // End training session
  fastify.post('/api/training/sessions/:sessionId/end', async (request: FastifyRequest<{ Params: { sessionId: string } }>, reply: FastifyReply) => {
    try {
      const { sessionId } = request.params;

      await fastify.db.query(
        'UPDATE user_meetings SET status = $1, updated_at = NOW() WHERE id = $2',
        ['completed', sessionId]
      );

      return {
        success: true,
        data: {
          message: 'Session ended successfully'
        }
      };

    } catch (error) {
      console.error('End session error:', error);
      return reply.status(500).send({
        success: false,
        error: 'Internal server error'
      });
    }
  });

  // Get stage data
  fastify.get('/api/training/stages/:stageId', async (request: FastifyRequest<{ Params: { stageId: string } }>, reply: FastifyReply) => {
    try {
      const { stageId } = request.params;

      const stageResult = await fastify.db.query(
        'SELECT * FROM stage_packs WHERE id = $1',
        [stageId]
      );

      if (!stageResult.rows[0]) {
        return reply.status(404).send({
          success: false,
          error: 'Stage not found'
        });
      }

      const stage = stageResult.rows[0];

      // Get question cards for this stage
      const cardsResult = await fastify.db.query(
        'SELECT * FROM question_cards WHERE stage_id = $1',
        [stageId]
      );

      return {
        success: true,
        data: {
          stage: {
            id: stage.id,
            name: stage.name,
            objective: stage.objective,
            mustCover: stage.must_cover
          },
          cards: cardsResult.rows
        }
      };

    } catch (error) {
      console.error('Get stage error:', error);
      return reply.status(500).send({
        success: false,
        error: 'Internal server error'
      });
    }
  });

  // Get all stages
  fastify.get('/api/training/stages', async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const result = await fastify.db.query(
        'SELECT * FROM stage_packs ORDER BY id'
      );

      return {
        success: true,
        data: result.rows.map(stage => ({
          id: stage.id,
          name: stage.name,
          objective: stage.objective,
          mustCover: stage.must_cover
        }))
      };

    } catch (error) {
      console.error('Get stages error:', error);
      return reply.status(500).send({
        success: false,
        error: 'Internal server error'
      });
    }
  });

  // Record hint event
  fastify.post('/api/training/hint-events', async (request: FastifyRequest<{ Body: HintEventRequest }>, reply: FastifyReply) => {
    try {
      const { sessionId, stageId, cardId, eventType, payload } = request.body;

      const result = await fastify.db.query(
        `INSERT INTO hint_events (
          session_id, 
          stage_id, 
          card_id, 
          event_type, 
          payload, 
          created_at
        ) VALUES ($1, $2, $3, $4, $5, NOW()) 
        RETURNING *`,
        [sessionId, stageId, cardId, eventType, JSON.stringify(payload || {})]
      );

      return {
        success: true,
        data: {
          eventId: result.rows[0].id,
          eventType: result.rows[0].event_type,
          createdAt: result.rows[0].created_at
        }
      };

    } catch (error) {
      console.error('Hint event error:', error);
      return reply.status(500).send({
        success: false,
        error: 'Internal server error'
      });
    }
  });

  // Get user credits
  fastify.get('/api/training/credits/:userId', async (request: FastifyRequest<{ Params: { userId: string } }>, reply: FastifyReply) => {
    try {
      const { userId } = request.params;

      const result = await fastify.db.query(
        'SELECT * FROM user_credits WHERE user_id = $1',
        [userId]
      );

      const credits = result.rows[0] || {
        user_id: userId,
        practice_credits: 10,
        assess_credits: 5,
        created_at: new Date(),
        updated_at: new Date()
      };

      return {
        success: true,
        data: {
          userId: credits.user_id,
          practiceCredits: credits.practice_credits,
          assessCredits: credits.assess_credits
        }
      };

    } catch (error) {
      console.error('Get credits error:', error);
      return reply.status(500).send({
        success: false,
        error: 'Internal server error'
      });
    }
  });

  // Use credits
  fastify.post('/api/training/credits/use', async (request: FastifyRequest<{ Body: { userId: string; type: 'practice' | 'assess' } }>, reply: FastifyReply) => {
    try {
      const { userId, type } = request.body;

      const creditField = type === 'practice' ? 'practice_credits' : 'assess_credits';

      const result = await fastify.db.query(
        `UPDATE user_credits 
         SET ${creditField} = ${creditField} - 1, updated_at = NOW() 
         WHERE user_id = $1 AND ${creditField} > 0 
         RETURNING *`,
        [userId]
      );

      if (result.rows.length === 0) {
        return reply.status(400).send({
          success: false,
          error: 'Insufficient credits'
        });
      }

      return {
        success: true,
        data: {
          userId: result.rows[0].user_id,
          practiceCredits: result.rows[0].practice_credits,
          assessCredits: result.rows[0].assess_credits
        }
      };

    } catch (error) {
      console.error('Use credits error:', error);
      return reply.status(500).send({
        success: false,
        error: 'Internal server error'
      });
    }
  });
}







